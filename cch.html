<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Retro Farm â€” Single File</title>
<style>
  html,body{height:100%;margin:0;background:#111;color:#ddd;font-family:monospace}
  .wrap{display:flex;gap:16px;padding:12px}
  canvas{image-rendering:pixelated;border:6px solid #222;background:#88c}
  .ui{width:260px}
  h1{font-size:18px;margin:0 0 8px}
  p{margin:6px 0}
  .stat{background:#151515;padding:8px;border-radius:6px}
  button{appearance:none;border:0;padding:8px;background:#2b2b2b;color:#ddd;border-radius:6px;cursor:pointer}
  .hint{font-size:12px;color:#aaa}
</style>
</head>
<body>
<div class="wrap">
  <canvas id="game" width="512" height="384"></canvas>
  <div class="ui">
    <h1>Retro Farm</h1>
    <div class="stat">
      <div>Day: <span id="day">1</span></div>
      <div>Money: $<span id="money">0</span></div>
      <div>Harvested: <span id="harvested">0</span></div>
      <div>Seeds: <span id="seeds">10</span></div>
    </div>
    <p class="hint">Controls: arrow keys to move, <b>Space</b> to plant, <b>W</b> to water, <b>H</b> to harvest, <b>S</b> to sell all, <b>P</b> pause</p>
    <p><button id="reset">Reset Farm</button></p>
    <p class="hint">A retro-styled mini farming game: prepare soil, plant seeds, water, wait for crops to grow, harvest and sell.</p>
  </div>
</div>
<script>
// Retro Farm - single file
// Grid-based pixel farm. Small, self-contained, and easy to extend.

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const SCALE = 4;           // pixel scale for retro look
const TILE_W = 16;         // tiles horizontally
const TILE_H = 12;         // tiles vertically
const TILE_SIZE = 16;      // logical pixels per tile
canvas.width = TILE_W * TILE_SIZE * SCALE;
canvas.height = TILE_H * TILE_SIZE * SCALE;
ctx.scale(SCALE, SCALE);
ctx.imageSmoothingEnabled = false;

// Game state
let day = 1;
let money = 0;
let harvested = 0;
let seeds = 10;
let paused = false;

const tileTypes = {
  grass: 0,
  soil: 1
};

// Each tile holds: type, seed (null or species), growth (0..max), watered (bool)
const grid = [];
for (let y=0;y<TILE_H;y++){
  const row = [];
  for (let x=0;x<TILE_W;x++){
    // make a central plottable area
    const isSoil = (y>2 && y<TILE_H-1 && x>1 && x<TILE_W-2);
    row.push({type: isSoil?tileTypes.soil:tileTypes.grass, seed:null, growth:0, watered:false});
  }
  grid.push(row);
}

// Simple crop definitions
const CROPS = {
  carrot: {name:'Carrot', growTime:3, sell:5},
  potato: {name:'Potato', growTime:5, sell:9}
};
const defaultCrop = 'carrot';

// Player
const player = {x: Math.floor(TILE_W/2), y: Math.floor(TILE_H/2)};

// Timing
let ticks = 0;
const TICKS_PER_DAY = 10; // advance growth every N ticks

// UI elements
const dayEl = document.getElementById('day');
const moneyEl = document.getElementById('money');
const harvestedEl = document.getElementById('harvested');
const seedsEl = document.getElementById('seeds');
const resetBtn = document.getElementById('reset');
resetBtn.addEventListener('click', resetGame);

function resetGame(){
  day = 1; money = 0; harvested = 0; seeds = 10; paused=false;
  for (let y=0;y<TILE_H;y++) for (let x=0;x<TILE_W;x++) grid[y][x].seed=null, grid[y][x].growth=0, grid[y][x].watered=false;
  player.x = Math.floor(TILE_W/2); player.y = Math.floor(TILE_H/2);
}

// Input
const keys = {};
window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; handleKey(e); e.preventDefault(); });
window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false; });

function handleKey(e){
  const k = e.key.toLowerCase();
  if (k === 'p') paused = !paused;
  if (paused) return;
  if (k === ' '){ // plant
    plantSeed();
  } else if (k === 'w'){
    waterTile();
  } else if (k === 'h'){
    harvest();
  } else if (k === 's'){
    sellAll();
  }
}

function plantSeed(){
  const t = grid[player.y][player.x];
  if (t.type !== tileTypes.soil) return; // only on soil
  if (t.seed) return; // already planted
  if (seeds <= 0) return;
  t.seed = defaultCrop;
  t.growth = 0;
  t.watered = false;
  seeds -= 1;
}
function waterTile(){
  const t = grid[player.y][player.x];
  if (t.type !== tileTypes.soil) return;
  if (!t.seed) { t.watered = true; return; } // pre-water
  t.watered = true;
}
function harvest(){
  const t = grid[player.y][player.x];
  if (!t.seed) return;
  const crop = CROPS[t.seed];
  if (t.growth >= crop.growTime){
    money += crop.sell;
    harvested += 1;
    t.seed = null; t.growth = 0; t.watered = false;
  }
}
function sellAll(){
  // sell based on money from harvested crops already collected (this is extra: let's give buyer price for mock inventory)
  // In this simple demo we just get a small bonus per harvested
  const bonus = Math.floor(harvested * 0.5);
  money += bonus;
}

// Game logic tick
function gameTick(){
  if (paused) return;
  ticks++;
  // player movement by arrow keys
  if (keys['arrowleft'] || keys['a']) player.x = Math.max(0, player.x-1);
  if (keys['arrowright'] || keys['d']) player.x = Math.min(TILE_W-1, player.x+1);
  if (keys['arrowup'] || keys['w']) player.y = Math.max(0, player.y-1);
  if (keys['arrowdown'] || keys['s']) player.y = Math.min(TILE_H-1, player.y+1);

  if (ticks % TICKS_PER_DAY === 0){
    // new day: advance crop growth if watered
    day++;
    for (let y=0;y<TILE_H;y++){
      for (let x=0;x<TILE_W;x++){
        const t = grid[y][x];
        if (t.seed){
          if (t.watered){
            t.growth = Math.min(CROPS[t.seed].growTime, t.growth+1);
          } else {
            // if not watered, slight chance to lose growth
            if (Math.random() < 0.15 && t.growth>0) t.growth = Math.max(0, t.growth-1);
          }
          t.watered = false; // reset watering each day
        }
      }
    }
  }
}

// Rendering
function draw(){
  // clear
  ctx.fillStyle = '#88c';
  ctx.fillRect(0,0,canvas.width/SCALE,canvas.height/SCALE);

  // draw grid
  for (let y=0;y<TILE_H;y++){
    for (let x=0;x<TILE_W;x++){
      const t = grid[y][x];
      const px = x*TILE_SIZE, py = y*TILE_SIZE;
      // base
      if (t.type === tileTypes.grass){
        rect(px,py, TILE_SIZE, TILE_SIZE, '#2b7');
        // grass pattern
        rect(px+1,py+1,4,2,'#167');
      } else {
        rect(px,py, TILE_SIZE, TILE_SIZE, '#7a4');
        // soil texture
        for (let i=0;i<3;i++) rect(px+2+i*4, py+3+i*2, 2,2, '#5b3');
      }

      // if soil and watered show overlay
      if (t.type === tileTypes.soil && t.watered){
        rect(px+2,py+2, TILE_SIZE-4, TILE_SIZE-4, 'rgba(30,144,255,0.14)');
      }

      // seed / crop
      if (t.seed){
        const crop = CROPS[t.seed];
        const stage = t.growth; // 0..growTime
        const max = crop.growTime;
        // draw simple plant as rectangles growing taller
        const height = Math.floor((stage/max) * (TILE_SIZE-4)) + 2;
        const cx = px + TILE_SIZE/2 - 2;
        const cy = py + TILE_SIZE - height - 2;
        rect(cx, cy, 4, height, stage >= max ? '#e36' : '#3a3');
        // if ready, draw spark
        if (stage >= max) rect(cx-2, cy-2, 8,2, '#ffd');
      }

      // tile grid lines
      strokeRect(px,py, TILE_SIZE, TILE_SIZE, 'rgba(0,0,0,0.2)');
    }
  }

  // player
  rect(player.x*TILE_SIZE+3, player.y*TILE_SIZE+3, TILE_SIZE-6, TILE_SIZE-6, '#fdd');
  // eyes
  rect(player.x*TILE_SIZE+6, player.y*TILE_SIZE+6, 2,2, '#000');
  rect(player.x*TILE_SIZE+10, player.y*TILE_SIZE+6, 2,2, '#000');

  // HUD text in canvas
  ctx.fillStyle = '#000';
  ctx.font = '8px monospace';
  ctx.fillText('Retro Farm', 6, 10);

  // update DOM UI
  dayEl.textContent = day;
  moneyEl.textContent = money;
  harvestedEl.textContent = harvested;
  seedsEl.textContent = seeds;
}

function rect(x,y,w,h,color){
  ctx.fillStyle = color;
  ctx.fillRect(x,y,w,h);
}
function strokeRect(x,y,w,h,color){
  ctx.strokeStyle = color;
  ctx.strokeRect(x+0.5,y+0.5,w-1,h-1);
}

// Main loop
let last = performance.now();
function loop(now){
  const dt = now-last;
  if (dt > 100) { // tick every ~100ms
    for (let i=0;i<Math.floor(dt/100);i++) gameTick();
    last = now;
  }
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// Small autoplay planting helper to make demo lively
setInterval(()=>{
  if (paused) return;
  // occasionally add seeds to keep playing
  if (Math.random() < 0.05) seeds++;
}, 3000);

// Prevent arrow keys scrolling
window.addEventListener('keydown', function(e){ if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault(); });

</script>
</body>
</html>
